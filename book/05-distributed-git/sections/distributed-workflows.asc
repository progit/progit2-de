=== Verteilte Workflows

(((workflows)))
Im Gegensatz zu CVCSs (Centralized Version Control Systems - Zentrale Versionsverwaltungs Systeme) können Sie dank der verteilten Struktur von Git die Zusammenarbeit von Entwicklern in Projekten wesentlich flexibler gestalten. In zentralisierten Systemen ist jeder Entwickler ein Knoten, der mehr oder weniger gleichermaßen mit einem zentralen System arbeitet.
In Git ist jedoch jeder Entwickler möglicherweise sowohl ein Knoten als auch ein zentrales System. Das heißt, jeder Entwickler kann sowohl Code für andere Repositorys bereitstellen als auch ein öffentliches Repository verwalten, auf dem andere ihre Arbeit aufbauen und zu dem sie beitragen können. Dies bietet eine Vielzahl von Workflow Möglichkeiten für Ihr Projekt und/oder Ihrem Team, sodass wir einige gängige Paradigmen behandeln, welche die Vorteile dieser Flexibilität nutzen. Wir werden die Stärken und möglichen Schwächen der einzelnen Designs untersuchen. Sie können ein einzelnes Design auswählen oder Eigenschaften aus diesen kombinieren.

==== Zentralisierter Workflow

(((workflows, centralized)))
In zentralisierten Systemen gibt es im Allgemeinen ein einziges Kollaborationsmodell - den zentralisierten Workflow. Ein zentraler Hub oder _Repository_ kann Code akzeptieren und jeder synchronisiert seine Arbeit mit ihm. Eine Reihe von Entwicklern sind Knoten - Nutzer dieses Hubs - und synchronisieren ihre Arbeit mit diesem zentralisierten Standort.

.Zentralisierter Workflow.
image::images/centralized_workflow.png[Zentralisierter Workflow.]

Dies bedeutet, wenn zwei Entwickler vom Hub klonen und beide Änderungen vornehmen, der erste Entwickler, der die Änderungen zurückgespielt hat, dies problemlos tun kann. Der zweite Entwickler muss die Arbeit des ersten Entwicklers zusammenführen (mergen), bevor seine Änderungen aufgenommen werden können, damit die Änderungen des ersten Entwicklers nicht überschrieben werden. Dieses Konzept ist in Git genauso wahr wie in Subversion(((Subversion))) (oder ein anderes beliebiges CVCS), und dieses Modell funktioniert in Git wunderbar.

Wenn Sie bereits mit einem zentralisierten Workflow in Ihrem Unternehmen oder Team vertraut sind, können Sie diesen Workflow problemlos mit Git weiterverwenden. Richten Sie einfach ein einziges Repository ein und gewähren Sie allen Mitgliedern Ihres Teams Schreib-Zugriff (push). Git lässt nicht zu, dass Benutzer sich gegenseitig überschreiben.

Sagen wir, John und Jessica fangen beide zur gleichen Zeit an zu arbeiten. John beendet seine Änderung und pusht sie zum Server. Dann versucht Jessica, ihre Änderungen zu pushen, aber der Server lehnt sie ab. Ihr wird gesagt, dass sie versucht, Änderungen 'non-fast-forward' zu pushen, und dass sie dies erst tun kann, wenn sie sie bestehende Änderungen abgeholt (gefetched) und mit ihrer lokalen Kopie vereint (gemergt) hat. Dieser Workflow ist für viele Menschen sehr ansprechend, weil er ein Paradigma ist, mit dem viele bereits bekannt und vertraut sind.

Diese Vorgehensweise ist nicht auf kleine Teams beschränkt. Mit dem Branching Model von Git ist es Hunderten von Entwicklern möglich, ein einzelnes Projekt über Dutzende von Branches gleichzeitig erfolgreich zu bearbeiten.

[[_integration_manager]]
==== Integration-Manager Workflow

(((workflows, integration manager)))

Da Sie in Git über mehrere Remote-Repositorys verfügen können, ist ein Workflow möglich, bei dem jeder Entwickler Schreibzugriff auf sein eigenes, öffentliches Repository und Lesezugriff auf die Repositorys aller anderen Entwickler hat. Dieses Szenario enthält häufig ein anerkanntes Repository, das das "offizielle" Projekt darstellt. Um zu diesem Projekt beizutragen, erstellen Sie Ihren eigenen öffentlichen Klon des Projekts und pushen Ihre Änderungen darauf. Anschließend können Sie eine Anforderung an den Betreuer des Hauptprojekts senden, um Ihre Änderungen zu übernehmen (Pull Request). Der Betreuer kann dann Ihr Repository als Remote hinzufügen, Ihre Änderungen lokal testen, sie in ihrem Branch mergen und in ihr Repository zurück pushen.
Der Prozess funktioniert wie folgt (siehe <<wfdiag_b>>):

1. Die Projekt Betreuer pushen zu ihrem eigenen, öffentlichen Repository.
2. Ein Mitwirkender klont dieses Repository und nimmt Änderungen vor.
3. Der Mitwirkende pusht auf seine eigene öffentliche Kopie.
4. Der Mitwirkende sendet dem Betreuer eine E-Mail mit der Aufforderung, Änderungen zu übernehmen (Pull Request).
5. Der Betreuer fügt das Repository des Mitwirkenden als Remote hinzu und merged es lokal zusammen.
6. Der Betreuer pusht die zusammengeführten Änderungen an das Hauptrepository.

[[wfdiag_b]]
.Integration-Manager Workflow.
image::images/integration-manager.png[Integration-Manager Workflow.]

(((forking)))
Dies ist ein sehr häufiger Workflow mit Hub-basierten Tools wie GitHub oder GitLab, bei dem es einfach ist, ein Projekt zu forken und Ihre Änderungen in Ihren fork zu pushen, damit jeder sie sehen kann. Einer der Hauptvorteile dieses Ansatzes besteht darin, dass Sie weiterarbeiten können und der Verwalter des Haupt-Repositorys Ihre Änderungen jederzeit übernehmen kann. Die Mitwirkenden müssen nicht warten, bis das Projekt ihre Änderungen übernommen hat - jede Partei kann in ihrem eigenen Tempo arbeiten.

==== Diktator und Leutnants Workflow

(((workflows, dictator and lieutenants)))
Dies ist eine Variante eines Workflows mit mehreren Repositorys. Er wird im Allgemeinen von großen Projekten mit Hunderten von Mitarbeitern verwendet. Ein berühmtes Beispiel ist der Linux-Kernel. Verschiedene Integrationsmanager sind für bestimmte Teile des Repositorys verantwortlich. Sie heißen _Leutnante_. Alle Leutnante haben einen Integrationsmanager, den wohlwollenden Diktator. Der wohlwollende Diktator pusht von seinem Verzeichnis in ein Referenz-Repository, aus dem alle Mitarbeiter pullen müssen. Der Prozess funktioniert wie folgt (siehe <<wfdiag_c>>):

1. Entwickler arbeiten regelmäßig an ihrem Topic Branch und reorganisieren (rebasen) ihre Arbeit auf `master`. Der `Master`-Branch ist der des Referenz-Repositorys, in das der Diktator pusht.
2. Die Leutnants fassen die Topic Branches der Entwickler zu ihrem `Master`-Branch zusammen.
3. Der Diktator merged die `Master`-Branch der Leutnants in den `Master`-Branch des Diktators zusammen.
4. Schließlich pusht der Diktator diesen `Master` -Branch in das Referenz-Repository, damit die anderen Entwickler darauf rebasen können.

[[wfdiag_c]]
.Wohlwollender Diktator Workflow.
image::images/benevolent-dictator.png[Wohlwollender Diktator Workflow.]

Diese Art von Workflow ist nicht üblich, kann jedoch in sehr großen Projekten oder in sehr hierarchischen Umgebungen hilfreich sein. Es ermöglicht dem Projektleiter (dem Diktator), einen Großteil der Arbeit zu delegieren und große Teilmengen von Code an mehreren Stellen zu sammeln, bevor sie integriert werden.

==== Zusammenfassung

Dies sind einige häufig verwendete Workflows, die mit einem verteilten System wie Git möglich sind. Allerdings sind auch viele Variationen möglich, um Ihren eigenen Arbeitsabläufen gerecht zu werden. Nachdem Sie (hoffentlich) bestimmen können, welche Workflow-Kombination für Sie geeignet ist, werden wir einige spezifischere Beispiele für die Ausführung der Hauptfunktionen behandeln, aus denen die verschiedenen Abläufe bestehen. Im nächsten Abschnitt erfahren Sie mehr über einige gängige Muster, um zu einem Projekt etwas beizutragen.